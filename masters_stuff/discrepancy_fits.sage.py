
# This file was *autogenerated* from the file discrepancy_fits.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_70 = Integer(70); _sage_const_100 = Integer(100); _sage_const_101 = Integer(101); _sage_const_p01 = RealNumber('.01'); _sage_const_10 = Integer(10); _sage_const_p1 = RealNumber('.1')#################################################
## Calculates the star discrepancy of the 
## theta twiddles, and attempts to fit to 
## C*N^(-1)*(log N)^n*(log log N)^(1+epsilon), 
## where s is the dimension, and where C is 
## a constant depending on epsilon and s
#################################################

def compute_points(N, f1, f2):
    datapts = []
    for n in range(_sage_const_1 , N+_sage_const_1 ):
        f1_temp = (float(n*f1) % float(pi))
        f1_twid = f1_temp/float(pi)
        f2_temp = (float(n*f2) % float(pi))
        f2_twid = f2_temp/float(pi)
        P = (f1_twid, f2_twid)
        datapts.append(P)
    return datapts
def count_pts_in_interval(x, y, points):
    numpts = _sage_const_0 
    for pt in points:
        if pt[_sage_const_0 ] < x and pt[_sage_const_1 ] < y:
            numpts = numpts + _sage_const_1 
    return numpts
def calculatediscrep(thetapoints, N):
    stepsize = _sage_const_p01 
    xs = [stepsize*j for j in range(_sage_const_1 , _sage_const_1 /stepsize +_sage_const_1  )]
    ys = [stepsize*j for j in range(_sage_const_1 , _sage_const_1 /stepsize +_sage_const_1  )]
    worstx = _sage_const_0 
    worsty = _sage_const_0 
    sup = _sage_const_0 
    print(N)
    for x in xs:
        for y in ys:
           ptcount = count_pts_in_interval(x, y, thetapoints)
           dis_xy = ptcount/N - x*y
           if dis_xy>sup:
               worstx = x
               worsty = y
               sup = dis_xy
    return sup
maxdeg = _sage_const_100 
datapts = [] #an item is of the form (extension degree, discrep)
#Ns = [j*10 for j in range(1, floor(maxdeg/10)+1)]
Ns = [_sage_const_70 ]
p = _sage_const_101 
t1 = _sage_const_7 
t2 = _sage_const_1 
f1 = arccos(t1/(_sage_const_2 *sqrt(p)))
f2 = arccos(t2/(_sage_const_2 *sqrt(p)))
thetapts = compute_points(maxdeg, f1, f2)
for N in Ns:
    pts = thetapts[_sage_const_1 :N]
    discrepN = calculatediscrep(pts, N)
    P = (N, discrepN)
    print(P)
    datapts.append(P)
#print(datapts)
var('C, x')
epsilon = _sage_const_p1 
__tmp__=var("x"); model = symbolic_expression(C*x**(-_sage_const_1 )*log(x)*(log(log(x)))**(_sage_const_1 +epsilon)).function(x)
bfit = find_fit(datapts, model)
print("best fit has C = " + str(bfit))
__tmp__=var("x"); f = symbolic_expression(model(C=bfit[_sage_const_0 ].rhs())).function(x)
p1 = plot(points(datapts))
p2 = plot(f(x), (x, _sage_const_10 , maxdeg))
show(p1+p2)

